
def  PatternToNumber(Pattern):
	SymbolToNumber= { "A":0, "C":1, "G":2,"T":3}
	if len(Pattern)==0:
		return 0
	return 4*PatternToNumber(Pattern[:-1])+SymbolToNumber[Pattern[-1]]

def NumberToPattern(index,k):
	NumberToSymbol ={ 0:"A", 1:"C", 2:"G",3:"T"}
	if k==1:
		return NumberToSymbol[index]
	prefixIndex = index//4
	r = index%4
	symbol = NumberToSymbol[r]
	prefixPatter = NumberToPattern(prefixIndex,k-1)
	return prefixPatter+symbol

def ComputingFrequencies(text, k):
	freqArray=[0]*((4**k))
	for i in range(len(text)-k+1):
		freqArray[PatternToNumber(text[i:i+k])]+=1
	return freqArray

def ClumpFinding(genome, k, L, t):
	FrequentPatterns = []
	Clumps=[0]*((4**k))
	freqArray = ComputingFrequencies(genome[:L],k)	
	for index in range((4**k)):
		if freqArray[index]>=t:
			Clumps[index]=1				
	for i in range(1,len(genome)-L+1):				
		freqArray[PatternToNumber(genome[i-1:i-1+k])]-=1
		index =PatternToNumber(genome[i+L-k:i+L])
		freqArray[index]+=1		
		if freqArray[index]>=t:
			Clumps[index]=1
	for i in range((4**k)):
		if Clumps[i] ==1:
			FrequentPatterns.append(NumberToPattern(i,k))
	return FrequentPatterns


# genome="CGGACTCGACAGATGTGAAGAACGACAATGTGAAGACTCGACACGACAGAGTGAAGAGAAGAGGAAACATTGTAA"
# genome="AAAACGTCGAAAAA"
# genome="ACGTACGT"
#genome="CCACGCGGTGTACGCTGCAAAAAGCCTTGCTGAATCAAATAAGGTTCCAGCACATCCTCAATGGTTTCACGTTCTTCGCCAATGGCTGCCGCCAGGTTATCCAGACCTACAGGTCCACCAAAGAACTTATCGATTACCGCCAGCAACAATTTGCGGTCCATATAATCGAAACCTTCAGCATCGACATTCAACATATCCAGCG"
#genome ="CCGCCCGCCATGGAACTATGTTGACAAGTTAATTTTACATGACTGCGCGACTGCGAAGAGATGTAAGCAGCCTAGATTCAACCAATCACATCTACCCGTCACTATCCCGCGCACACATTCCTCTTAGTAACAAGGGGCCTCTCTTAACATGAAGTCTGCCTTGTCTCTATAAAGGCAGCAGACCCAAGACAAAGAGCTGCCTCCGTTGAGCTAGAGTCTCCAGCGCATCGAGTGCATATGGACAAGACGACTGTCCTTAAACTGGGTTGCGAGGCCAAAAGGCTCCAAAGAGCTAAAGGCCAAAAGGCGTAGGTATGGACCGGATGCGGTGGCCAAAAGGAGACCGAGCGCGGTCAAGTACGGCCAGGCCAAAAGGCCGGCCAAAAGGGATAATCAATTTGTCTTAACGGCCAAAAGGCTAACGCAATTTGTCTTTGTCTGGACGTCCTTGTGCAGCCGGCCAAAAGGCTTCCTCGACAATTTGTCTTATACCGCGGGCCAAAAGGTTAAGGGGGCCAAAAGGGTTGTCTAGCCAAGGCCAAAAGGGAACAGCGCGGCCAAAAGGGCCAAAAGGAACATACCGATTGATAGGCCAAAAGGTTGTCGGCCAAAAGGGCTAGCGGATATATTCCTCTCTTGGCCAAAAGGTTAGCGGGCCAAAAGGGGCCAAAAGGCCAAAAGGTCCCGGTCAATTTGTCTCTTTTTATATCAATTTGTCTCAATTTGTCTCTGATCGCCCCTCAATTTGTAGAACAAGCAGGGTGAGCGGGGTAGAACAAGCAGATAGAACAAGCGCCAAAAGGAAAGGACCTAGCGGGCCAAAATAGAACAAGCGCCTTAGAACAAGTAGAACAAGCACGTTTAATCGAAAAGAGTATGCTAGAACAAGCGATCTAGCGTGAGCGGCAGTATCTAGAACAAGCTGTCTTAGCGTGACAACACTAGAACTAGAACAAGCATTTGTCTGAGTTTCTGTACATTTTGCTAGATCTAGGCGAGATTATAGAACATATTTCTGTACACCGGCACTATAGCGTGAGCACCGGTTTTTCTTTTCTGTACAATTTCTGTACAGCGATAGAACAAGCCGTAGCGTGAGTAGAACAAGCAGCGTTTCTGTACATACAAGAATTTCTGTACATAGAACAAGCCGTGAGCTCGTTAGAACAAGCCCGAGGGAAACTGTGAATATGAATTGGGCCGTCAAAGTTTCTGTACACCTTCTTTCTGTACAAAGCAAACCTCCTGTCCTTTTTTCTTTTCTGTACATCTGTACAAAGCGCTTTCTGTACAGATTTCTGTATTTCTGTACAAGAATTTCTGTACACAAGCACTGTGTATTAAAACTACCAGCATGTTTCTGTACTTTCTGTACAGTGTTTATAGATTCTCTCAACTTAAGAAGCAATTTCTGTACACCCTTTTCTGTACACTCACCTTCGCTAGCTTTGTGTTTTTCTGTACATCACCTTTCTTTTCTGTACAGTAACGGTCAGTCCGGACCGCAAGTATATATCTTTCTGTACACAATTTCTGTACACAAGCAGTAACGCCGATCTCTGGGATTTTGGAGATTTTCTTGAGGGGAAACCCGGCTGGTTCCAGGGAGTTGAAAACTAGGATAAAGCTGAATCCCCTGTGTCGATGATTGTATAACTGGCCTTTATTGTCATCCAGCGGCCCGCCCGGCCAGGATTCGTCTACAGTACAAAATTCGGGAAGATAGTCCTATCCGAACTATTTTTCTACAACCTATTAGTGCTGAACGCAAACGCTAAGTACAATAATAATTACACCTATTAAACGCGACCAAGCTTTTACTGCACGATGAGAGCTCCCCACAACTAGATAAGATTTCCCTGTATGACTCCCGTCAGTAGCGAGCACCAGGAGAGTACCGGGGCAGTCACCACACAAAGTCAGTTATTTGGTGGTCTGCTGGCCTATATTTGATCAGAAATTTCTCTCACGCTCCTGGTTACCCCGGTCTTTGTTGAACGCACGGTAGGACCATAGGGACAGAGGCCCGACTGATGAGACGGCACCTGATAGCGGTTGGATCTTTTAACTGGATGTGGATGCCTAACTGGATTAACTGGATGACACGTGGGAACGGGTTAACCAGAGCTAACTGGATGCCACCTATAACTGGATGTTAAACATTCTGTACACTAGCGCTGCTAAGATATAGGTTATAACTGGATGCAGTAACTGGATGGTAACTGGATGATGAGGGCAACATGTTTGCTGGAATTAACTGGATGAGCTCATAGACATTATGTTATGTTCTAGACCTTCTTACGATAATAACTGGATGCTTAACTGGATGGTGACCGTTGGGGAAGAGCGCCCAAACGCATCATAATAACTGGATGTGCGATCTCCGGCACAGCTTGTCATAAGTTGCGAATTCACAGGTGTCCTAACTGGATGCAGCTTTTCCCAGACAGGTCTCCCCAGGTCATGGGCCACTTGATACAGATAACTGGATGGGGGTAACTGGATGAGTTGTAACTAACTGGATGTAACTGGATGGCCTCCAGTATCGCTTTCTAGTAGGTGTATTTTAACTGGATGATAGTAACTGGATGTATCAATATAACTGGATGAGTGATCTAACTGGTAACTGGATGGAGATTTATGAAGTTAACTGGATGAGCGACCGTGTGTCGAGGCGTACACACTTATGCGGCTAACATTCTATACCAGCTCAGACTTCATGACACACCGAGAGGGATCTACACTACAAGTTGGATACACCCACCCATCCGAGTATGAAGTCCATAAAGGCACTCAGATTCAGAAAACCGACGGGCTAGTTAATCTAGCCATTAAGGGCGACATCCAGGTGCATGGGTTGTTTGATCATGGATGAACAGCCCCCAGTGATACGGACAGCTTAAATCGTAGCCGTGACGTCTACCGGCGGACCACAGCACCCAGAAGTGGCATTAGCACGCTGTTGTTGTTTTTCAATCGGCACTAGGAGCTTAGTTGCACTTATTTCATTTATCACAATTGAAGTCATGCGCGAATGGCAATCCAACGTCCTAATTTCTGTGAGTGTCGATAGCCCGGGTGCAACATAAATGAGCCCTATTATGGCTATGGTGTTGATTGAAGCCCTAGGGGTGGGCATTTCCTAGGATTCTGGCAGGGCTCAATGAGTGGTACACCCTAATTCACCGGTGATAAGGACGCCCGCGCAACAGCAGAACAAAGCGCGGCCTCGTGATAAATTGGGCCTGCGATCACACCTGGGCCTGCGACCGTTAGCTTGAAACCTGTTGGGCCTGCGTTTGTCAGGATTTATTGTATGGGCCTGCGGTGGGCCTGCGTTGGAGGCGCCATGGGCCTGCGTGCGGAGCAGCGACAAAGGGCACACTGACGGTCGCACTATTTCTGGGCCTGGGCCTGCGGCCTGCGGCGGTGGGCCTGCGCCCAATGGGCCTGCGATTTGGAAAATACCCCTTCGACAGTGGGCCTGCGAGACGTTATCTGGGCCTGTGGGTGGGCCTGCGCGTTGGGCCTGCGGGGGGGCCCAGCAGGGTCCTGGTGGGCTGGGTGGGCCTGCGTACAAACGACACTGTTTGTGGGCCTGCGGGGAGGTGGGGCGATTCCTACGGATGCATGCACTCAGTGGTTAATAATTTGCTCTGATGGGCCTGCGCTGTGTACCGAATGGGCCTGCGAGCTGGGCCTGCGTACTTTATGTTACAGGGTGGGCCTGCGGCCTGCGGACATGCAATAAGGCGGTGGGCCTGCGGGCATCGGATTACGAAGTTGGTTGAACACCCGCATTCAAAAGAATACGAAGTTGTACGAAGTTGCCTGTGCTCCAATATATACGAAGTTGGGATATTTTCTCCATTACGAAGTTGGTTGTACGAAGTTGGCGGTTACCTACGAAGTTGCAGTGATACGAAGTTGATTGAAAAGCTAGAGCCCTACGAAGTTGGGACAGAACGGTGTACGAAGTTGGCGACATATAGAGGTACATAGTCAGCTCCTACGAAGTTGGATAGCTACGAAGTTACGAAGTTGAATTGATTTAGATGCGTTTGCCAGTAATGGTACGAAGTTGACACTGGTAAGCTTATATTGCTTACGAAGTTGGAGTAACTGCCGCTGTAAACCGGACGTCCCAATTACGAAGTTTACGAAGTTGCCGACTGCCATCGCATACTTTCGGTTGAAAATACTACGAAGTTGAGTTGTTACCAAGTACGAAGGGGTTGAAAATAAAAATATTACGAAGTTGGCAGGGTGTTGAAAATAAGAAACCAGTTGAAAATACCTTAGGCTGACAGTTGAAAATACGAAGTTGTTGTGACGGCCACCTACGAGTTGAAAATAGAAAGGAGTTGAAAATATGCTGGTGCGAGTATCGCAATGGATCGGGGTTACGTTGAAAATAGGGAGGTTGAAAATAAAATACTAAGACAGGTTGAAAATAGTTGAAAATAGACACCCGCGCATCGCGCATTGGTTGAAAAGTTGAAAATACGTTGAAAATAAGGAGCGGGTCGGGCCGGGGTTCGTTGAAAGTTGAAAATATGGTTGAAAATAAGTGGAGGAGGAGAATTTAGGTTGAAAATAGCATTACGTTGAAAATAGTTGAAAATAAAAATACGTTGAGGGCAACACCTGTGGTTGAAAATAGGACACCGTTGAAAATACGACCTGTTGAAAATATAGATGAATTATACTGACGAGGACAGCATTCGTTGAAAATATAAGATGGATTAGGCTCCAAAGTTCCTATGCCGCATTGACGTTGCGTTGCTGGACAGGTTAGTGAACAATTCACCCTGAGTCAACCAACCGAGTACCCTTATTACCATGACTATCACCGGCGTTCGTGATTGAAGATTGGGACGTATAAGTTATTACTTATTACCATTCTTGTCGGCTTATTACCATTACCATCCATGCTTGAACAAGGGTTCGATTGGTATGACTGATTGCATTATTATTACCATATTACCATCCTTATTACCATCCATACCATCGCCTTCAGGACCCCGGTGCGTGTTATTACCATAATTATTACCATTAACATGTCGGCCTTATTACCATTATTACCATACCTTGTCTAGTGATACAATCTTACGTCGGCTTACTACTGCGGATTTATTACCATATTATTACCATCGGCCAATCTGGAAATAAGAGCTATCAGGCTCTGCTGGGACTCGGAATACTTATTACCATGCTAGGTCCCGAGTAAGAGTCGAACCGGTTTTTATTACCATTCCACCTAATCAGGCCCTATCCACATCCACCTTTATTTTATTACCATCATCCACCTTATTACCTTATTACCATAAGCTATTATCCACCTAAAATCCACCTAACTTCCTTATTACCATCTTTTATTACCATCACGCAATCCACCTAAGCCCTGCCTTGATTAAAGCATCCACCTAATCAGCCAACCAATATCCACCTAAACCATCCACCTAATTAGTGATCCACCTAATCCACCTAAAGTCAATCCACCTAAATCCACCTAATTTCCATATCCACCTAAAATCCACCTAAATCAATTTCCAAAATTGCGAATACACCCATCCACCTAATAAACATCCACCTAAGTTTATTTAGAACACCCGGTGAAACTCTACGAACGTTTTATTGCCGCACCAGAGCCAACGAGTCTTCGGCCTTTATTCAATCCACCTAACTATGTGAAGGCGCTAATTCGGGTCGTGGATTCTCGCAGAGTGAAGGCGCCGGTGTGGATGTCGAAATTCCTATACAATCCACCTAATAATCCACCTAATCCAGTGAAGGCGCGCACGCACGATAGCATCACGGTGAAGGCGCGGTGAAGGCGCCTAATTCGGATTGTGTGAAGGCGCTAACTCGCGCACTAGTGAAGGCGCACAAACTATATTTCCCCTCAGCATGGCCAAGTGAAGGCGGTGAAGGCGCGGCGCCGCTCCCGCGGCGAAATGGGGTGAAGGCGCCCGTGAAGGCGCCAAAGGCGGGTGTAGATGACGGACAGCTTGGTGAAGGCGCACAAAGTGTGCTAGTGGGGCTCCCCCAGTATCGCTTGACGGTGAAGGCGCACCAGATACGTGAAGGCGCCAATGACGCGTATCTGTGAAGGCGCCGCGTGAAGGCGCCGAAAAGTGAAGGCGTGAAGGCGCATGAGTGAAGGCGCATTGAGGTGAAGGCGCGGTAGCGGTGAAGGCGCATCTAGTGAGTGAAGGCGCGAGTGAAGGCGCACGCATGGCGGGATAGGTCAGCATGCGGGGAGAAAGGCCAGGGGGAGAGATCGTCTTGCATTCCAAATGAACTATCCACAGCGTCAAGAGTCCTACGCTCCGGGGCCATACTAACTCCCGAGAACTCGGACCATTGTAATCAGACCTGGCGGACAGATGATTGGACCCTCTAAAACATTCCTCGTCTCGTTAAATCCAGCAGAACAAAGTTGGAACTCAAAAACGTCGACACCTGTCAGGCTGCAGTGTACGTGGCGACTAAGTCAGTACGGAGTGGTTGGATCCAGCCGGCTGACTTAATGAGTCTCTGACTCATCCGGCGAGCAGGGGCTTTCTATTTTGTCTTAGATGAGTATAAAACCCTTGGCTTCGTGGTATAAATGTGGTCCCGGTCTCTTTTACGCCCTCAGCTTCACGTATGGGCGTTACTCAAAATTATAATCAGAGACGTGGAAATTTTAATCCGCGATCCATTATGTCGACGGCGGAGGATCTAGACTAGACGGATCTGCGCTCTATAGATGAATGGCCTATAGACGCTTCATAGGCCTGGGCGATAGCGTTCCAACAAAAGGATGTTCCCAGTAGAGTAGGCCCATAAATTATTTACACTTGCGTCGCACTGGTGCACTGTAAGACTTCCGCTCGACTGGATCAGTAATAACGTCGGTAGAAAGTTAAGGATAGCTACAACGTAACTGCGGCTAAAAGAGACCGCAAGCGAGCAAATGTTGACACAGATAAGATACTCATGGCCAACCGAGTGGGATATACAGCCTGCCGTGGCCATAGATGCCCTGCATGGATCTCTTCCGGCAGCTTTGTGCGGACTGAGTATACACCTCTTTGGGGCAGAGCCGGATTGGGGACATTTTGGGCACACACGCGCGATAAACCGCTCGGTTGAAACACCTAACAACGACTATAAACTATGGCTATCCGAGCTCGTCCATATCAATCTTCTACGTATGGTTCTTCCCGGTCGCCCAAGTTACCAACAATAGTCAAACCTTCTTCGAATGTTTTTTCCAATTCCATGCGAAAGCTGAAACATTTTCAAGGTGTGCCACACGCTCGCGCATTGCCGCTTCCGCCCTCAGTGTCTCTGAAGCGGGCCGCGCGCCACAGTCTAATCTGCCTATAAACTATCGGTGGCGGGAAGGGTGGTGGGCAGCAGCTCCTACGTCGTATCGGACGACGAGTAGCGATGACACAGTTGGCTGGGTACCAAACAGCTCCAGGTTCCTGAGCCGTGTTCTGCGACACACCGCAATTTTATTTTCGTGCTTAAGTCATCATCGCTTTGGATCCAGTGAGTCATAGCCTGTAGAATTGATGGAGAAGACCCGAAACTGTTGGGGAAATGACCCCTTCCAAGTTCTATGGTGGGCGGTGTTTTCGTGCTACCGGTGATTCTGGGCGCTGGGGCTTGCCAAATGGGTAGGATAGTTACTTTGAACACTAACATTTTGTGCTGCCGACTGGCGATACGTGGGTGTCAAGCTAACCACTTCGCTGTCTGATACACGTGCCGATGCGCGTTAATGGTTGGGAACCTTGGAATCTTGGTCCTCACGTGGGACGATGTTGACATCGCCCCGGTCATTATAGCCTTAGGACGGCGGTGTACGCCCATCGGAAGCAATCGATGCCTCAGTGACCTCCTGATTGTGCTCGTTTACCGGAGATTCTCTCCAAGTATAATTGCACTCCAGACGGACAGTGTGTCAAGGTAGGGGGACTAGGTGTAGTCGAAGTGCCCTGAGACTCCGTCACGTAAGGGATCGGATATAAGTTTGAACATCTATCAATAGCAAATACGGGGGCACGATAGAGCCGGGGCAGATGGCTAGCGGTGTGCAACTTGGCCAAAGTCACGTACGGCACTTAGAGGGATATGGCGGGCCACCAGCAACTCGGGAACAACTGTTCCCTTGACTCCGACAGTGTGGCTGTGTGTAAGCCGCTCTCTCCTGCTTCCAGGGACGATTACTAGGCATTCGGAGGTTAGGATAAAAGGGTGCAGCGAGGCGGTCAACATTACGTCGTGCCAATTGGGCTCAAGAATGCGCTTCATAAAAGACTCATTCTAGGGGGCTACCATGGCGACGAAATCGAGTGAGAAACCTGGGCAGCTTAGAGAATAGTCTGGTCCGCTATTCATCAGTAGCTGGACGTTAACTGATCTTCTCCTATTGCCTAGTCATTCAGTCTTCTTTTGGACCGCGCCTGACTCCCGGTAGCCATAAAGCCTTAGCGGATGCAAGATTCGTAGTTAGCAAACTCTGGTTCCGTCTGGCTGGCTTCGAAGGCTAATGGGTAAGACCTGCAGACAACTCCACGGACGAACGGGTGTTGAGCGCGGCGGGGCACCGAGGACGGCCCAGCCACCTTAGGAGGTGTGAGCCAAACTTGCAATACTATCAGGGTGCGCCTATGCGGCAGTATATAACCGCACCCTCGGGAACAGAATTTGGGAGAACTCTCGTGCTTGTACTTAACGCAAGTCTGTCCGTTTCTTCGATAGCCCAATCCAAACGAATTGCGCTGACGATAAGTGTAGGTCCAATCGTGGTGCCGTCGCACAAGTCTGTTGGGCCACGGAGTGGCTAGGACGAGGTGGGGTTCGGCAGTCCAGAACGCTCACGCAAGTAGGAGTTCGTTTGAATAGCGGTCTACATACGTTAGCTAACTAGGATATCCCACTATCCCACCGTATCCCACCGTATCCTATCCCACCGCACCGTATCCCACCGTATCCCACCGTATCCCACCGTATCCCACCGTATCCCATATCCCACCGCCTATTATCCCACCGTCCCACCGTATCCCACCGTATCCCACCGTATCCCACCGTATCCCACCGTATCCCACCGTATCCCACCGTTATCCCACCGTATCCCACCGTATCCCACCGTATCCCACCGTATCCCACCGTATCCCACCGTATCCCACCG"

def PatternCount(Text, Pattern):
	count=0
	for i in range(len(Text)-len(Pattern)+1):
		if Pattern == Text[i:i+len(Pattern)]:
			count+=1
	return count

# print PatternCount("ACTGTACGATGATGTGTGTCAAAG", "TGT")

def FrequentWords(Text,k):
	count=[]
	FrequentPatterns=[]
	for i in range(len(Text)-k+1):
		count.append(PatternCount(Text,Text[i:i+k]))
	maxCount = max(count)
	for i in range(len(count)):
		if count[i]==maxCount:
			FrequentPatterns.append(Text[i:i+k])
	return list(set(FrequentPatterns))

# print FrequentWords("TAAACGTGAGAGAAACGTGCTGATTACACTTGTTCGTGTGGTAT",3)


def ReverseComplement(Pattern):
	dict={"A":"T","T":"A","C":"G","G":"C"}	
	return "".join([dict[x] for x in Pattern])[::-1]

# print ReverseComplement("GATTACA")
def PatternMatching(Pattern, Genome):
	k=len(Pattern)
	t=len(Genome)
	return [i for i in range(t-k+1) if Pattern==Genome[i:i+k]]





def Skew(Genome):
	vals = {"A":0,"C":-1, "G":1,"T":0}
	skewArray=[0]
	for i in range(1, len(Genome)+1):
		skewArray.append(skewArray[i-1]+vals[Genome[i-1]])
	return skewArray


# def MinimumSkew(Genome):
# 	vals = {"A":0,"C":-1, "G":1,"T":0}
# 	skewArray=[0]
# 	minValue = 1000
# 	for i in range(1, len(Genome)+1):
# 		skewArray.append(skewArray[i-1]+vals[Genome[i-1]])
# 		if minValue > skewArray[i]:
# 			minValue = skewArray[i]
# 			indexes=[i]
# 		elif minValue ==skewArray[i]:
# 			indexes.append(i)
# 	return indexes

def MinimumSkew(Genome):
	vals = {"A":0,"C":-1, "G":1,"T":0}
	skewArray=[0]
	minValue = 1000
	for i in range(1, len(Genome)+1):
		skewArray.append(skewArray[i-1]+vals[Genome[i-1]])		
	indexes = [i for i in range(len(skewArray)) if skewArray[i]==min(skewArray)]
	return indexes

# print "MIN SKEW: ",MinimumSkew("CATTCCAGTACTTCGATGATGGCGTGAAGA")


def MaximumSkew(Genome):
	vals = {"A":0,"C":-1, "G":1,"T":0}
	skewArray=[0]
	for i in range(1, len(Genome)+1):
		skewArray.append(skewArray[i-1]+vals[Genome[i-1]])		
	indexes = [i for i in range(len(skewArray)) if skewArray[i]==max(skewArray)]
	return indexes

#print Skew("CATTCCAGTACTTCATGATGGCGTGAAGA")
# file = open("dataset_7_6.txt","r")
# text = file.read().strip()
# print MinimumSkew(text)

def HammingDistance(p, q):
	hd = 0
	for pi,qi in zip(p,q):
		if pi!=qi:
			hd+=1
	return hd


# print "HAMMING: ",HammingDistance("CAGAAAGGAAGGTCCCCATACACCGACGCACCAGTTTA","CACGCCGTATGCATAAACGAGCCGCACGAACCAGAGAG")

def ApproximatePatternMatching(Text, Pattern, d):    
	L=len(Text)
	k=len(Pattern)
	return [i for i in range(L-k+1) if HammingDistance(Pattern,Text[i:i+k])<=d]

 # file = open("dataset_9_3.txt","r")
 # l1 = file.readline()
 # l2 = file.readline()
 # print HammingDistance(l1,l2)

# file = open("dataset_9_4.txt","r")
# Pattern=file.readline().strip()
# Text=file.readline().strip()
# d=int(file.readline().strip())
# print ApproximatePatternMatching(Text,Pattern,d)


def ApproximatePatternCount(Text, Pattern, d):
	L=len(Text)
	k=len(Pattern)
	return len([i for i in range(L-k+1) if HammingDistance(Pattern,Text[i:i+k])<=d])
# file = open("dataset_9_6.txt","r")
# Pattern=file.readline().strip()
# Text=file.readline().strip()
# d=int(file.readline().strip())

# print "COUNT1:", ApproximatePatternCount("TACGCATTACAAAGCACA", "AA",1)
# print ApproximatePatternCount("CATGCCATTCGCATTGTCCCAGTGA", "CCC",2)

# print ApproximatePatternCount(Text, Pattern, d)
	
def Neighbors(Pattern, d):
	nucleotides = ["A","C","G","T"]
	if d==0:		
		return [Pattern]	
	if len(Pattern)==1:
		return set(nucleotides)
	Neighborhood = set()
	SuffixNeighbors = Neighbors(Pattern[1:],d)
	for text in SuffixNeighbors:
		if HammingDistance(text,Pattern[1:])<d:
			for nucleotide in nucleotides:
				Neighborhood.add(nucleotide+text)
		else:
			Neighborhood.add(Pattern[0]+text)	
	return Neighborhood

# def ComputingFrequenciesWithMismatches(Text, k, d):
# 	close =[0]*(4**k) #All the posibilities.	
# 	for i in range(len(Text)-k+1):
# 		Pattern = Text[i:i+k]		
# 		Neighborhood=Neighbors(Pattern,d)
# 		print Neighborhood		
# 		for neighbor in Neighborhood:
# 			aproxPattern = ApproximatePatternMatching(Text,neighbor,d)			
# 			for index in aproxPattern:
# 				print Text[index:index+k]
# 				close[PatternToNumber(Text[index:index+k])]+=1	
# 	return close

# def FrequentWordsWithMismatches(Text,k,d):	
# 	FrequentPatterns=[]	
# 	count=ComputingFrequenciesWithMismatches(Text,k,d)
# 	print count
# 	maxCount = max(count)
# 	for i in range(len(count)):
# 		if count[i]==maxCount:
# 			FrequentPatterns.append(Text[i:i+k])
# 	return list(set(FrequentPatterns))


def FrequentWordsWithMismatches(Text, k, d):
	close =[0]*(4**k) #All the posibilities.
	Neighborhood=[]
	for i in range(len(Text)-k+1):
		Pattern = Text[i:i+k]		
		Neighborhood+=Neighbors(Pattern,d)	
	Neighborhood=list(set(Neighborhood))
	for neighbor in Neighborhood:			
		close[PatternToNumber(neighbor)]+=ApproximatePatternCount(Text,neighbor,d)
	maximum = max(close)
	return [NumberToPattern(i,k) for i in range(len(close)) if close[i]==maximum]


def ComputingFrequentWordsWithMismatches(Text, k, d):
	close =[0]*(4**k) #All the posibilities.
	Neighborhood=[]
	for i in range(len(Text)-k+1):
		Pattern = Text[i:i+k]		
		Neighborhood+=Neighbors(Pattern,d)	
	Neighborhood=list(set(Neighborhood))
	for neighbor in Neighborhood:			
		close[PatternToNumber(neighbor)]+=ApproximatePatternCount(Text,neighbor,d)
	return close
# def FrequentWordsWithMismatchesAndReverseComplements(Text, k, d):
# 	close =[0]*(4**k) 	
# 	closeRev =[0]*(4**k) 	
# 	Neighborhood=[]
# 	NeighborhoodRev=[]
# 	for i in range(len(Text)-k+1):
# 		Pattern = Text[i:i+k]		
# 		Neighborhood+=Neighbors(Pattern,d)
# 		NeighborhoodRev+=Neighbors(ReverseComplement(Pattern),d)
# 	for i in range(len(Neighborhood)):					
# 		close[PatternToNumber(Neighborhood[i])]+=ApproximatePatternCount(Text,Neighborhood[i],d)
# 		closeRev[PatternToNumber(NeighborhoodRev[i])]+=ApproximatePatternCount(Text,NeighborhoodRev[i],d)
# 	res = [close[i]+closeRev[i] for i in range(len(close))]
# 	maximum = max(res)		
# 	return [NumberToPattern(i,k) for i in range(len(res)) if res[i]==maximum]

# def FrequentWordsWithMismatchesAndReverseComplements(Text, k, d):
# 	close =[0]*(4**k) 	
# 	closeRev =[0]*(4**k) 	
# 	Neighborhood=[]
# 	NeighborhoodRev=[]
# 	for i in range(len(Text)-k+1):
# 		Pattern = Text[i:i+k]		
# 		Neighborhood+=Neighbors(Pattern,d)		
# 	for neighbor in Neighborhood:
# 		j = PatternToNumber(neighbor)
# 		close[j]+=ApproximatePatternCount(Text,neighbor,d)		
# 		NeighborhoodRev=Neighbors(ReverseComplement(neighbor),d)
		
# 		if neighbor in NeighborhoodRev:
# 			NeighborhoodRev.remove(neighbor)
# 		print NeighborhoodRev
# 		print"----------------------------------------------------"
# 		for neighborrev in NeighborhoodRev:
# 			rev=PatternToNumber(neighborrev)
# 			close[rev]+=ApproximatePatternCount(Text,neighborrev,d)	
# 	print len(close)
# 	print close
# 	maximum = max(close)		
# 	return [NumberToPattern(i,k) for i in range(len(close)) if close[i]==maximum]


# def FrequentWordsWithMismatchesAndReverseComplements(Text, k, d):
# 	close =[0]*(4**k) 	
# 	# closeRev =[0]*(4**k) 
# 	for i in range(len(Text)-k+1):		
# 		Pattern =Text[i:i+k]				
# 		PatternRev = ReverseComplement(Pattern)
# 		Neighborhood = Neighbors(Pattern,d)
# 		for neighbor in Neighborhood:
# 			close[PatternToNumber(neighbor)]+=ApproximatePatternCount(Text,neighbor,d)		
# 		Neighborhood = Neighbors(PatternRev,d)
# 		for neighbor in Neighborhood:
# 			close[PatternToNumber(neighbor)]+=ApproximatePatternCount(Text,neighbor,d)		
	
# 	maximum = max(close)
# 	vec = [NumberToPattern(i,k) for i in range(len(close)) if close[i]==maximum]
# 	final=[]		
# 	for v in vec:
# 		final.append(v)
# 		final.append(ReverseComplement(v))
# 	return sorted(list(set(final)))


def FrequentWordsWithMismatchesAndReverseComplements(Text, k, d):		
	array1 = ComputingFrequentWordsWithMismatches(Text, k, d)
	array2 = ComputingFrequentWordsWithMismatches(ReverseComplement(Text), k, d)
	close = [array1[i]+array2[i] for i in range(len(array1))]
	maximum = max(close)
	return [NumberToPattern(i,k) for i in range(len(close)) if close[i]==maximum]



# Text = "AGTAGCAGCATTAAGCATTAAAGTTGCAGCATTGCATAAGAAAGTTAAAGAGGCATTGCAGCATTGCAGCATTTAAGAGGCATAAGAGGCAAGTTAATTGCAGCAAGTAAGAATAGCAAAAGAGTAGCAAGGCATTAAGCAAAGCAAATTAGTATATAAGAGGCATTAGGCAAAAATAAGGCAGCAAGAAGCAAGAATATAGCAAATTTATAAGTTAAAGAGAAAAGCAGCAGCAAGTTAGAGAAAG"
# k= 7
# d= 2
# "AAA","AAT","ACA","AGA","ATA","ATC","ATG","ATT","CAT","CTA","GAT","GTA","TAA","TAC","TAG","TAT","TCT","TGT","TTA","TTT"
# Text = "ACGTTGCATGTCGCATGATGCATGAGAGCT"
# k= 4
# d= 1
# output=["ACAT","ATGT"]
# output2 = ['ATGC', 'ATGT', 'GATG']
# # print FrequentWordsWithMismatches(Text,k,d)
# print " ".join(sorted(FrequentWordsWithMismatchesAndReverseComplements(Text,k,d)))




def MotifEnumeration(Dna,k,d):
	Patterns=[0]*(4**k)	
	count=0
	Neighborhood=[]	
	lines=0
	for line in Dna:
		lines+=1
		for i in range(len(line)-k+1):
			Neighborhood+=(Neighbors(line[i:i+k],d))	
	Neighborhood=list(set(Neighborhood))
	for neighbor in Neighborhood:		
		for line in Dna:			
			if ApproximatePatternCount(line,neighbor,d)>0:
				Patterns[PatternToNumber(neighbor)]+=1
	return [NumberToPattern(i,k) for i in range(len(Patterns)) if Patterns[i]>=lines]





def DistanceBetweenPatternAndStrings(Pattern, Dna):
	k = len(Pattern)
	distance = 0
	for line in Dna:
		hm = 200000
		for i in range(len(line)-k+1):
			p = line[i:i+k]
			hm2=HammingDistance(p,Pattern)
			if hm > hm2:
				hm = hm2
		distance+=hm
	return distance


# file = open("dataset_5164_1.txt","r")
# Pattern = file.readline().strip()
# Dna=file.readline().split()

# print Pattern
# print Dna
# print DistanceBetweenPatternAndStrings(Pattern,Dna)


def MedianString(Dna,k):
	distance = 100000
	for i in range(4**k):
		Pattern = NumberToPattern(i,k)
		d = DistanceBetweenPatternAndStrings(Pattern,Dna)
		if distance > d:
			median = Pattern
			distance = d
	return median

k= 6
Dna = ["AGCAAGGCGAGAGATAAGAAGGAGGGAGGTTAGACTTAGGCT",
"GCCTTCACGAGATGTGTAGCGATATTGAGATGTCGGCGGGTT",
"CTGCTCGCTTCGGAACAAGCGACACAATATTCTGGGTCTGCC",
"GCGAAAAAAACTAGATCGCGGTTATGCTGTGCCTGTAGGCTT",
"GCGAGATTATAACAAAGAGGAATGTTTTTCGGTGCCCAAGAC",
"GCGAAAGAAACTTCCTTCTACATCAAGGGCGGCTGCGCCAGC",
"GCGACATGACAAGAATCATAACCACTATTGACGCCAAAGGTT",
"ACGCCCTATGTGTATAGCGCGACAAGCGGCATGATACCGCTG",
"GCGAGACGACTGAAAAACTTTCGCGCCCTCCTCTTTTAGGGA",
"TGCCGAGGATGCCAACTCTAGAAAACGAAAGCGATACTCCGA"]

print MedianString(Dna,k)